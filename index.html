<!DOCTYPE html>
<html lang="ar">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>متاهة تفاعلية</title>
  <style>
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      margin: 0;
      min-height: 100vh;
      background-color: #f4f4f4;
      text-align: center;
    }
    .instructions {
      margin-bottom: 20px;
      font-size: 1.2em;
      color: #333;
    }
    .maze-container {
      width: 90%;
      max-width: 800px;
      height: 400px;
      overflow: auto;
      border: 2px solid #333;
      background-color: #fff;
      position: relative;
      touch-action: none;
    }
    canvas {
      display: block;
      width: 1200px;
      height: 1200px;
    }
  </style>
</head>
<body>
  <div class="instructions">
    <h1>متاهة تفاعلية</h1>
    <p>اسحب المربع الأخضر للوصول إلى المربع الأزرق دون المرور عبر الجدران!</p>
  </div>
  <div class="maze-container" id="mazeContainer">
    <canvas id="mazeCanvas" width="1200" height="1200"></canvas>
  </div>
  <script>
    const canvas = document.getElementById('mazeCanvas');
    const container = document.getElementById('mazeContainer');
    const ctx = canvas.getContext('2d');
    const gridSize = 40;
    const cellSize = canvas.width / gridSize;
    let maze = [];
    const directions = [
      [0, -1], [1, 0], [0, 1], [-1, 0]
    ];

    let player = { x: 1, y: 1 };
    const goal = { x: gridSize - 3, y: gridSize - 3 };
    let dragging = false;

    let touchCount = 0;
    let initialTouch = { x: 0, y: 0 };
    let lastTouch = { x: 0, y: 0 };

    // Variables for zoom
    let initialDistance = 0; // The distance between two touches at the start
    let scale = 1; // Default scale factor
    const minScale = 0.5; // Minimum scale (zoom out)
    const maxScale = 2; // Maximum scale (zoom in)

    function initializeMaze(size) {
      const maze = [];
      for (let y = 0; y < size; y++) {
        const row = [];
        for (let x = 0; x < size; x++) {
          row.push(1);
        }
        maze.push(row);
      }
      return maze;
    }

    function generateMazeWithSinglePath(startX, startY, endX, endY) {
      maze[startY][startX] = 0;
      let stack = [[startX, startY]];

      while (stack.length > 0) {
        let [x, y] = stack[stack.length - 1];

        if (x === endX && y === endY) {
          stack.pop();
          continue;
        }

        let shuffledDirections = directions.sort(() => Math.random() - 0.5);
        let carved = false;

        for (const [dx, dy] of shuffledDirections) {
          const nx = x + dx * 2;
          const ny = y + dy * 2;

          if (
            nx > 0 &&
            nx < gridSize - 1 &&
            ny > 0 &&
            ny < gridSize - 1 &&
            maze[ny][nx] === 1
          ) {
            maze[y + dy][x + dx] = 0;
            maze[ny][nx] = 0;
            stack.push([nx, ny]);
            carved = true;
            break;
          }
        }

        if (!carved) stack.pop();
      }
    }

    function isValidMove(x, y) {
      return x >= 0 && x < gridSize && y >= 0 && y < gridSize && maze[y][x] === 0;
    }

    function isValidDragMove(startX, startY, endX, endY) {
      const dx = endX - startX;
      const dy = endY - startY;

      if (Math.abs(dx) > 1 || Math.abs(dy) > 1) return false;
      if (!isValidMove(endX, endY)) return false;

      return true;
    }

    function drawMaze() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const scaledCellSize = cellSize * scale;
      for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
          ctx.fillStyle = maze[y][x] === 1 ? '#000' : '#fff';
          ctx.fillRect(x * scaledCellSize, y * scaledCellSize, scaledCellSize, scaledCellSize);
        }
      }

      ctx.fillStyle = '#32CD32';
      ctx.fillRect(player.x * scaledCellSize, player.y * scaledCellSize, scaledCellSize, scaledCellSize);

      ctx.fillStyle = '#87ceeb';
      ctx.fillRect(goal.x * scaledCellSize, goal.y * scaledCellSize, scaledCellSize, scaledCellSize);
    }

    function getPointerPos(e) {
      const rect = canvas.getBoundingClientRect();
      const x = Math.floor((e.touches[0].clientX - rect.left) / (cellSize * scale));
      const y = Math.floor((e.touches[0].clientY - rect.top) / (cellSize * scale));
      return { x, y };
    }

    function calculateDistance(touch1, touch2) {
      return Math.sqrt(
        Math.pow(touch2.clientX - touch1.clientX, 2) + Math.pow(touch2.clientY - touch1.clientY, 2)
      );
    }

    container.addEventListener('touchstart', (e) => {
      touchCount = e.touches.length;
      
      if (touchCount === 1) {
        const { x, y } = getPointerPos(e);
        if (x === player.x && y === player.y) {
          dragging = true;
          initialTouch.x = e.touches[0].clientX;
          initialTouch.y = e.touches[0].clientY;
        }
      } else if (touchCount === 2) {
        initialDistance = calculateDistance(e.touches[0], e.touches[1]);
        lastTouch.x = e.touches[1].clientX;
        lastTouch.y = e.touches[1].clientY;
      }
    });

    container.addEventListener('touchmove', (e) => {
      touchCount = e.touches.length;

      if (touchCount === 2) {
        // Zoom in/out with two fingers
        e.preventDefault(); // Prevent default zoom behavior

        const newDistance = calculateDistance(e.touches[0], e.touches[1]);
        const scaleFactor = newDistance / initialDistance;

        // Apply zoom scale within bounds
        scale = Math.min(maxScale, Math.max(minScale, scale * scaleFactor));

        initialDistance = newDistance;
        drawMaze();
      } else if (touchCount === 1 && dragging) {
        // Handle dragging with one finger
        e.preventDefault();
        const { x, y } = getPointerPos(e);
        const dx = e.touches[0].clientX - initialTouch.x;
        const dy = e.touches[0].clientY - initialTouch.y;

        if (isValidDragMove(player.x, player.y, x, y)) {
          player.x = x;
          player.y = y;
          drawMaze();
          initialTouch.x = e.touches[0].clientX;
          initialTouch.y = e.touches[0].clientY;
          if (player.x === goal.x && player.y === goal.y) alert('تهانينا!');
        }
      }
    });

    container.addEventListener('touchend', (e) => {
      touchCount = e.touches.length;
      if (touchCount === 0) dragging = false;
    });

    maze = initializeMaze(gridSize);
    generateMazeWithSinglePath(1, 1, gridSize - 2, gridSize - 2);
    drawMaze();
  </script>
</body>
</html>
