<!DOCTYPE html>
<html lang="ar">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title> v6 متاهة تفاعلية</title>
  <style>
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      margin: 0;
      min-height: 100vh;
      background-color: #f4f4f4;
      text-align: center;
    }
    .instructions {
      margin-bottom: 20px;
      font-size: 1.2em;
      color: #333;
    }
    .maze-container {
      width: 90%;
      max-width: 800px;
      height: 400px;
      overflow: hidden;
      border: 2px solid #333;
      background-color: #fff;
      position: relative;
      touch-action: none;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <div class="instructions">
    <h1>متاهة تفاعلية</h1>
    <p>اسحب المربع الأخضر للوصول إلى المربع الأزرق دون المرور عبر الجدران!</p>
  </div>
  <div class="maze-container" id="mazeContainer">
    <canvas id="mazeCanvas" width="1200" height="1200"></canvas>
  </div>
  <script>
    const canvas = document.getElementById('mazeCanvas');
    const container = document.getElementById('mazeContainer');
    const ctx = canvas.getContext('2d');
    const gridSize = 40;
    const cellSize = 30;
    let maze = [];
    const directions = [
      [0, -1], [1, 0], [0, 1], [-1, 0]
    ];

    let player = { x: 1, y: 1 };
    const goal = { x: gridSize - 3, y: gridSize - 3 };
    let dragging = false;
    let zooming = false;
    let initialDist = 0;
    let lastTouch = { x: 0, y: 0 };

    let scale = 1; // Default scale factor
    const minScale = 0.5; // Minimum scale (zoom out)
    const maxScale = 2; // Maximum scale (zoom in)
    let offset = { x: 0, y: 0 }; // Canvas offset for translation

    function initializeMaze(size) {
      const maze = [];
      for (let y = 0; y < size; y++) {
        const row = [];
        for (let x = 0; x < size; x++) {
          row.push(1);
        }
        maze.push(row);
      }
      return maze;
    }

    function generateMazeWithSinglePath(startX, startY, endX, endY) {
      maze[startY][startX] = 0;
      let stack = [[startX, startY]];

      while (stack.length > 0) {
        let [x, y] = stack[stack.length - 1];

        if (x === endX && y === endY) {
          stack.pop();
          continue;
        }

        let shuffledDirections = directions.sort(() => Math.random() - 0.5);
        let carved = false;

        for (const [dx, dy] of shuffledDirections) {
          const nx = x + dx * 2;
          const ny = y + dy * 2;

          if (
            nx > 0 &&
            nx < gridSize - 1 &&
            ny > 0 &&
            ny < gridSize - 1 &&
            maze[ny][nx] === 1
          ) {
            maze[y + dy][x + dx] = 0;
            maze[ny][nx] = 0;
            stack.push([nx, ny]);
            carved = true;
            break;
          }
        }

        if (!carved) stack.pop();
      }
    }

    function isValidMove(x, y) {
      return x >= 0 && x < gridSize && y >= 0 && y < gridSize && maze[y][x] === 0;
    }

    function isValidDragMove(startX, startY, endX, endY) {
      const dx = endX - startX;
      const dy = endY - startY;

      if (Math.abs(dx) > 1 || Math.abs(dy) > 1) return false;
      if (!isValidMove(endX, endY)) return false;

      return true;
    }

    function drawMaze() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const scaledCellSize = cellSize * scale;
      for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
          ctx.fillStyle = maze[y][x] === 1 ? '#000' : '#fff';
          ctx.fillRect(x * scaledCellSize + offset.x, y * scaledCellSize + offset.y, scaledCellSize, scaledCellSize);
        }
      }

      ctx.fillStyle = '#32CD32';
      ctx.fillRect(player.x * scaledCellSize + offset.x, player.y * scaledCellSize + offset.y, scaledCellSize, scaledCellSize);

      ctx.fillStyle = '#87ceeb';
      ctx.fillRect(goal.x * scaledCellSize + offset.x, goal.y * scaledCellSize + offset.y, scaledCellSize, scaledCellSize);
    }

    function getPointerPos(e) {
      const rect = canvas.getBoundingClientRect();
      const x = Math.floor((e.touches[0].clientX - rect.left - offset.x) / (cellSize * scale));
      const y = Math.floor((e.touches[0].clientY - rect.top - offset.y) / (cellSize * scale));
      return { x, y };
    }

    function calculateDistance(touch1, touch2) {
      return Math.sqrt(
        Math.pow(touch2.clientX - touch1.clientX, 2) + Math.pow(touch2.clientY - touch1.clientY, 2)
      );
    }

    container.addEventListener('touchstart', (e) => {
      if (e.touches.length === 1) {
        const { x, y } = getPointerPos(e);
        if (x === player.x && y === player.y) {
          dragging = true;
        }
      } else if (e.touches.length === 2) {
        // When two fingers are detected, we check for zoom or pan
        zooming = false;
        initialDist = calculateDistance(e.touches[0], e.touches[1]);
        lastTouch.x = (e.touches[0].clientX + e.touches[1].clientX) / 2;
        lastTouch.y = (e.touches[0].clientY + e.touches[1].clientY) / 2;
      }
    });

    container.addEventListener('touchmove', (e) => {
      if (e.touches.length === 1 && dragging) {
        e.preventDefault();
        const { x, y } = getPointerPos(e);
        if (isValidDragMove(player.x, player.y, x, y)) {
          player.x = x;
          player.y = y;
          drawMaze();
        }
      } else if (e.touches.length === 2) {
        e.preventDefault();
        const dist = calculateDistance(e.touches[0], e.touches[1]);

        if (Math.abs(dist - initialDist) > 10) { // Only change scale if the distance changes significantly
          zooming = true;
          const scaleFactor = dist / initialDist;
          scale = Math.min(maxScale, Math.max(minScale, scale * scaleFactor));

          // Update the offset to keep the zoom centered on the previous midpoint
          offset.x -= (e.touches[0].clientX + e.touches[1].clientX) / 2 - lastTouch.x;
          offset.y -= (e.touches[0].clientY + e.touches[1].clientY) / 2 - lastTouch.y;

          lastTouch.x = (e.touches[0].clientX + e.touches[1].clientX) / 2;
          lastTouch.y = (e.touches[0].clientY + e.touches[1].clientY) / 2;

          drawMaze();
        } else {
          // Handle panning when no significant zoom change
          const dx = e.touches[0].clientX - e.touches[1].clientX;
          const dy = e.touches[0].clientY - e.touches[1].clientY;
          offset.x += dx / scale;
          offset.y += dy / scale;
          drawMaze();
        }
      }
    });

    container.addEventListener('touchend', () => {
      dragging = false;
      zooming = false;
    });

    function startGame() {
      maze = initializeMaze(gridSize);
      generateMazeWithSinglePath(1, 1, gridSize - 2, gridSize - 2);
      drawMaze();
    }

    startGame();
  </script>
</body>
</html>
